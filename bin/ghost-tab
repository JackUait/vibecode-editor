#!/bin/bash
set -e

# Wrap everything in a function so `curl | bash` reads the entire
# script into memory before executing.  Without this, bash reads
# line-by-line from the pipe and `read` consumes script lines as input.
main() {

# Determine where supporting files live
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
_brew_prefix="$(brew --prefix 2>/dev/null || true)"
if [[ -n "$_brew_prefix" && "$SCRIPT_DIR" == "$_brew_prefix/bin" ]]; then
    SHARE_DIR="$_brew_prefix/share/ghost-tab"
else
    SHARE_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"
fi

source "$SHARE_DIR/lib/tui.sh"

# ---------- OS check ----------
header "Checking platform..."
if [ "$(uname)" != "Darwin" ]; then
  error "This setup script only supports macOS."
  exit 1
fi
success "macOS detected"

# ---------- Homebrew ----------
header "Checking Homebrew..."
if ! command -v brew &>/dev/null; then
  info "Installing Homebrew..."
  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
  eval "$(/opt/homebrew/bin/brew shellenv 2>/dev/null || /usr/local/bin/brew shellenv 2>/dev/null)"
  success "Homebrew installed"
else
  success "Homebrew found"
fi

# ---------- Dependencies ----------
header "Installing dependencies..."
for pkg in tmux lazygit broot; do
  if brew list "$pkg" &>/dev/null; then
    success "$pkg already installed"
  else
    info "Installing $pkg..."
    if brew install "$pkg"; then
      success "$pkg installed"
    else
      warn "Failed to install $pkg — install it manually with: brew install $pkg"
    fi
  fi
done

# ---------- AI Coding Tools ----------
header "Setting up AI coding tools..."
echo ""
echo -e "  Ghost Tab supports multiple AI coding assistants."
echo -e "  Select which ones to install:"
echo ""

# Detect already installed tools
_cc_installed=0; command -v claude &>/dev/null && _cc_installed=1
_codex_installed=0; command -v codex &>/dev/null && _codex_installed=1
_copilot_installed=0; command -v copilot &>/dev/null && _copilot_installed=1
_oc_installed=0; command -v opencode &>/dev/null && _oc_installed=1

# Default selections: pre-check installed tools, always pre-check Claude Code
_sel_claude=1
_sel_codex=$_codex_installed
_sel_copilot=$_copilot_installed
_sel_opencode=$_oc_installed

# Display multi-select menu
_selecting=1
_cursor=0
while [ "$_selecting" -eq 1 ]; do
  # Move cursor up to redraw (skip first draw)
  [ -n "$_drawn" ] && printf '\033[5A'
  _drawn=1

  for _i in 0 1 2 3; do
    case $_i in
      0) _name="Claude Code"; _sel=$_sel_claude; _tag="" ;;
      1) _name="Codex CLI (OpenAI)"; _sel=$_sel_codex; _tag="" ;;
      2) _name="Copilot CLI (GitHub)"; _sel=$_sel_copilot; _tag="" ;;
      3) _name="OpenCode (anomalyco)"; _sel=$_sel_opencode; _tag="" ;;
    esac
    case $_i in
      0) [ "$_cc_installed" -eq 1 ] && _tag=" ${_YELLOW}(installed)${_NC}" ;;
      1) [ "$_codex_installed" -eq 1 ] && _tag=" ${_YELLOW}(installed)${_NC}" ;;
      2) [ "$_copilot_installed" -eq 1 ] && _tag=" ${_YELLOW}(installed)${_NC}" ;;
      3) [ "$_oc_installed" -eq 1 ] && _tag=" ${_YELLOW}(installed)${_NC}" ;;
    esac

    if [ "$_i" -eq "$_cursor" ]; then
      if [ "$_sel" -eq 1 ]; then
        echo -e "  ${_BOLD}❯ [x] ${_name}${_NC}${_tag}"
      else
        echo -e "  ${_BOLD}❯ [ ] ${_name}${_NC}${_tag}"
      fi
    else
      if [ "$_sel" -eq 1 ]; then
        echo -e "    [x] ${_name}${_tag}"
      else
        echo -e "    [ ] ${_name}${_tag}"
      fi
    fi
  done
  echo -e "  ${_BLUE}↑↓${_NC} navigate  ${_BLUE}Space${_NC} toggle  ${_BLUE}Enter${_NC} confirm"

  read -rsn1 _key </dev/tty
  if [[ "$_key" == $'\x1b' ]]; then
    read -rsn1 _s1 </dev/tty
    if [[ "$_s1" == "[" ]]; then
      read -rsn1 _s2 </dev/tty
      case "$_s2" in
        A) _cursor=$(( (_cursor - 1 + 4) % 4 )) ;;
        B) _cursor=$(( (_cursor + 1) % 4 )) ;;
      esac
    fi
  elif [[ "$_key" == " " ]]; then
    case $_cursor in
      0) _sel_claude=$(( 1 - _sel_claude )) ;;
      1) _sel_codex=$(( 1 - _sel_codex )) ;;
      2) _sel_copilot=$(( 1 - _sel_copilot )) ;;
      3) _sel_opencode=$(( 1 - _sel_opencode )) ;;
    esac
  elif [[ "$_key" == "" ]]; then
    # Require at least one selection
    if [ $(( _sel_claude + _sel_codex + _sel_copilot + _sel_opencode )) -eq 0 ]; then
      echo -e "  ${_RED}✗${_NC} Select at least one AI tool"
      sleep 0.8
      printf '\033[1A\033[K'
    else
      _selecting=0
    fi
  fi
done

echo ""

# Install Claude Code
if [ "$_sel_claude" -eq 1 ] && [ "$_cc_installed" -eq 0 ]; then
  info "Installing Claude Code..."
  if curl -fsSL https://claude.ai/install.sh | bash; then
    success "Claude Code installed"
    info "Run 'claude' to authenticate before opening Ghostty."
  else
    warn "Claude Code installation failed — install manually: curl -fsSL https://claude.ai/install.sh | bash"
  fi
elif [ "$_sel_claude" -eq 1 ]; then
  success "Claude Code already installed"
fi

# Install Codex CLI
if [ "$_sel_codex" -eq 1 ] && [ "$_codex_installed" -eq 0 ]; then
  info "Installing Codex CLI..."
  if brew install --cask codex; then
    success "Codex CLI installed"
  else
    warn "Codex CLI installation failed — install manually: brew install --cask codex"
  fi
elif [ "$_sel_codex" -eq 1 ]; then
  success "Codex CLI already installed"
fi

# Install Copilot CLI
if [ "$_sel_copilot" -eq 1 ] && [ "$_copilot_installed" -eq 0 ]; then
  info "Installing Copilot CLI..."
  if brew install copilot-cli; then
    success "Copilot CLI installed"
  else
    warn "Copilot CLI installation failed — install manually: brew install copilot-cli"
  fi
elif [ "$_sel_copilot" -eq 1 ]; then
  success "Copilot CLI already installed"
fi

# Install OpenCode
if [ "$_sel_opencode" -eq 1 ] && [ "$_oc_installed" -eq 0 ]; then
  info "Installing OpenCode..."
  if brew install anomalyco/tap/opencode; then
    success "OpenCode installed"
  else
    warn "OpenCode installation failed — install manually: brew install anomalyco/tap/opencode"
  fi
elif [ "$_sel_opencode" -eq 1 ]; then
  success "OpenCode already installed"
fi

# Save default AI tool preference (first selected tool)
AI_TOOL_PREF_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/ghost-tab"
mkdir -p "$AI_TOOL_PREF_DIR"
if [ "$_sel_claude" -eq 1 ]; then
  echo "claude" > "$AI_TOOL_PREF_DIR/ai-tool"
elif [ "$_sel_codex" -eq 1 ]; then
  echo "codex" > "$AI_TOOL_PREF_DIR/ai-tool"
elif [ "$_sel_copilot" -eq 1 ]; then
  echo "copilot" > "$AI_TOOL_PREF_DIR/ai-tool"
elif [ "$_sel_opencode" -eq 1 ]; then
  echo "opencode" > "$AI_TOOL_PREF_DIR/ai-tool"
fi
success "Default AI tool set to $(cat "$AI_TOOL_PREF_DIR/ai-tool")"

# ---------- Ghostty ----------
header "Checking Ghostty..."
if [ -d "/Applications/Ghostty.app" ]; then
  success "Ghostty found"
else
  info "Installing Ghostty..."
  if brew install --cask ghostty; then
    success "Ghostty installed"
  else
    error "Ghostty installation failed."
    info "Install manually from https://ghostty.org or run: brew install --cask ghostty"
    exit 1
  fi
fi

# Verify supporting files exist (will fail if run via curl|bash without clone)
if [ ! -f "$SHARE_DIR/ghostty/claude-wrapper.sh" ] || [ ! -f "$SHARE_DIR/ghostty/config" ]; then
  error "Supporting files not found in $SHARE_DIR"
  echo ""
  info "If you ran this via curl|bash, install via Homebrew instead:"
  echo "  brew tap JackUait/ghost-tab https://github.com/JackUait/ghost-tab"
  echo "  brew install ghost-tab"
  echo ""
  info "Or clone the repo:"
  echo "  git clone https://github.com/JackUait/ghost-tab.git"
  echo "  cd ghost-tab && ./bin/ghost-tab"
  exit 1
fi

# ---------- Wrapper script ----------
header "Setting up wrapper script..."
mkdir -p ~/.config/ghostty
cp "$SHARE_DIR/ghostty/claude-wrapper.sh" ~/.config/ghostty/claude-wrapper.sh
chmod +x ~/.config/ghostty/claude-wrapper.sh
success "Created claude-wrapper.sh in ~/.config/ghostty/"

# Copy shared libraries
if [ -d "$SHARE_DIR/lib" ]; then
  cp -R "$SHARE_DIR/lib" ~/.config/ghostty/lib
  success "Copied shared libraries to ~/.config/ghostty/lib/"
fi

# ---------- Ghostty config ----------
header "Setting up Ghostty config..."
GHOSTTY_CONFIG="$HOME/.config/ghostty/config"
WRAPPER_LINE="command = ~/.config/ghostty/claude-wrapper.sh"

if [ -f "$GHOSTTY_CONFIG" ]; then
  warn "Existing Ghostty config found at $GHOSTTY_CONFIG"
  echo ""
  echo -e "  ${_BOLD}1)${_NC} Merge — add the wrapper command to your existing config"
  echo -e "  ${_BOLD}2)${_NC} Backup & replace — save current config and use ours"
  echo ""
  read -rn1 -p "$(echo -e "${_BLUE}Choose (1/2):${_NC} ")" config_choice </dev/tty
  echo ""

  case "$config_choice" in
    1)
      if grep -q '^command\s*=' "$GHOSTTY_CONFIG"; then
        sed -i '' 's|^command\s*=.*|'"$WRAPPER_LINE"'|' "$GHOSTTY_CONFIG"
        success "Replaced existing command line in config"
      else
        echo "$WRAPPER_LINE" >> "$GHOSTTY_CONFIG"
        success "Appended wrapper command to config"
      fi
      ;;
    2)
      BACKUP="$GHOSTTY_CONFIG.backup.$(date +%s)"
      cp "$GHOSTTY_CONFIG" "$BACKUP"
      success "Backed up existing config to $BACKUP"
      cp "$SHARE_DIR/ghostty/config" "$GHOSTTY_CONFIG"
      success "Replaced config with ghost-tab defaults"
      ;;
    *)
      warn "Invalid choice, skipping config setup"
      ;;
  esac
else
  cp "$SHARE_DIR/ghostty/config" "$GHOSTTY_CONFIG"
  success "Created Ghostty config at $GHOSTTY_CONFIG"
fi

# Migrate from old config location
OLD_PROJECTS_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/vibecode-editor"
NEW_PROJECTS_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/ghost-tab"
if [ -d "$OLD_PROJECTS_DIR" ] && [ ! -d "$NEW_PROJECTS_DIR" ]; then
  mv "$OLD_PROJECTS_DIR" "$NEW_PROJECTS_DIR"
  info "Migrated config from vibecode-editor to ghost-tab"
fi

# ---------- Projects ----------
header "Setting up projects..."
PROJECTS_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/ghost-tab"
PROJECTS_FILE="$PROJECTS_DIR/projects"
mkdir -p "$PROJECTS_DIR"

echo ""
read -rn1 -p "$(echo -e "${_BLUE}Add a project? (y/n):${_NC} ")" add_project </dev/tty
echo ""

while [[ "$add_project" =~ ^[yY]$ ]]; do
  read -rp "$(echo -e "${_BLUE}Project name:${_NC} ")" proj_name </dev/tty
  read -rp "$(echo -e "${_BLUE}Project path:${_NC} ")" proj_path </dev/tty

  # Expand ~ to $HOME for validation
  expanded_path="${proj_path/#\~/$HOME}"

  if [ -d "$expanded_path" ]; then
    echo "$proj_name:$expanded_path" >> "$PROJECTS_FILE"
    success "Added $proj_name"
  else
    warn "Path $proj_path does not exist yet — adding anyway"
    echo "$proj_name:$expanded_path" >> "$PROJECTS_FILE"
  fi

  echo ""
  read -rn1 -p "$(echo -e "${_BLUE}Add another? (y/n):${_NC} ")" add_project </dev/tty
  echo ""
done

if [ -f "$PROJECTS_FILE" ] && [ -s "$PROJECTS_FILE" ]; then
  success "Projects saved to $PROJECTS_FILE"
else
  info "No projects added. Add them later to $PROJECTS_FILE"
fi

# ---------- Claude Code Status Line ----------
if [ "$_sel_claude" -eq 1 ]; then
header "Setting up Claude Code status line..."

# Check for npm, install Node.js LTS if needed
if ! command -v npm &>/dev/null; then
  info "Installing Node.js LTS..."
  if brew install node@22 &>/dev/null; then
    # Add node@22 to PATH for this session
    export PATH="/opt/homebrew/opt/node@22/bin:$PATH"
    success "Node.js LTS installed"
  else
    warn "Node.js installation failed — skipping status line setup"
  fi
fi

if command -v npm &>/dev/null; then
  # Install ccstatusline
  if npm list -g ccstatusline &>/dev/null; then
    success "ccstatusline already installed"
  else
    info "Installing ccstatusline..."
    if npm install -g ccstatusline &>/dev/null; then
      success "ccstatusline installed"
    else
      warn "Failed to install ccstatusline — skipping status line setup"
    fi
  fi

  if npm list -g ccstatusline &>/dev/null; then
    # Create ccstatusline config
    mkdir -p ~/.config/ccstatusline
    cat > ~/.config/ccstatusline/settings.json << 'CCEOF'
{
  "version": 3,
  "lines": [
    [
      {
        "id": "1",
        "type": "context-percentage",
        "color": "yellow",
        "bold": true,
        "rawValue": true
      }
    ],
    [],
    []
  ],
  "flexMode": "full-minus-40",
  "compactThreshold": 60,
  "colorLevel": 2,
  "inheritSeparatorColors": false,
  "globalBold": false,
  "powerline": {
    "enabled": false,
    "separators": [""],
    "separatorInvertBackground": [false],
    "startCaps": [],
    "endCaps": [],
    "autoAlign": false
  }
}
CCEOF
    success "Created ccstatusline config"

    # Create statusline scripts
    mkdir -p ~/.claude
    cat > ~/.claude/statusline-command.sh << 'SLCEOF'
#!/bin/bash
input=$(cat)
cwd=$(echo "$input" | sed -n 's/.*"current_dir":"\([^"]*\)".*/\1/p')

if git -C "$cwd" rev-parse --git-dir > /dev/null 2>&1; then
  repo_name=$(basename "$cwd")
  branch=$(git -C "$cwd" --no-optional-locks rev-parse --abbrev-ref HEAD 2>/dev/null)
  staged=$(git -C "$cwd" --no-optional-locks diff --cached --name-only 2>/dev/null | wc -l | tr -d ' ')
  unstaged=$(git -C "$cwd" --no-optional-locks diff --name-only 2>/dev/null | wc -l | tr -d ' ')
  untracked=$(git -C "$cwd" --no-optional-locks ls-files --others --exclude-standard 2>/dev/null | wc -l | tr -d ' ')

  printf '\033[01;36m%s\033[00m | \033[01;32m%s\033[00m | S: \033[01;33m%s\033[00m | U: \033[01;33m%s\033[00m | A: \033[01;33m%s\033[00m' \
    "$repo_name" "$branch" "$staged" "$unstaged" "$untracked"
else
  printf '\033[01;36m%s\033[00m' "$(basename "$cwd")"
fi
SLCEOF

    cat > ~/.claude/statusline-wrapper.sh << 'SLWEOF'
#!/bin/bash
input=$(cat)
git_info=$(echo "$input" | bash ~/.claude/statusline-command.sh)
context_pct=$(echo "$input" | npx ccstatusline 2>/dev/null)

# Find parent Claude Code process and get its memory usage
pid=$PPID
mem_label=""
while [ -n "$pid" ] && [ "$pid" != "1" ]; do
  comm=$(ps -o comm= -p "$pid" 2>/dev/null | xargs basename 2>/dev/null)
  if [ "$comm" = "claude" ]; then
    mem_kb=$(ps -o rss= -p "$pid" 2>/dev/null | tr -d ' ')
    if [ -n "$mem_kb" ] && [ "$mem_kb" -gt 0 ] 2>/dev/null; then
      mem_mb=$((mem_kb / 1024))
      if [ "$mem_mb" -ge 1024 ]; then
        mem_gb=$(echo "scale=1; $mem_mb / 1024" | bc)
        mem_label="${mem_gb}G"
      else
        mem_label="${mem_mb}M"
      fi
    fi
    break
  fi
  pid=$(ps -o ppid= -p "$pid" 2>/dev/null | tr -d ' ')
done

if [ -n "$mem_label" ]; then
  printf '%s | %s | \033[01;35m%s\033[00m' "$git_info" "$context_pct" "$mem_label"
else
  printf '%s | %s' "$git_info" "$context_pct"
fi
SLWEOF

    chmod +x ~/.claude/statusline-command.sh
    chmod +x ~/.claude/statusline-wrapper.sh
    success "Created statusline scripts"

    # Update Claude settings.json
    CLAUDE_SETTINGS="$HOME/.claude/settings.json"
    if [ -f "$CLAUDE_SETTINGS" ]; then
      # Check if statusLine already configured
      if grep -q '"statusLine"' "$CLAUDE_SETTINGS"; then
        success "Claude status line already configured"
      else
        # Add statusLine to existing settings
        # Remove trailing } and add statusLine config
        sed -i '' '$ s/}$/,\n  "statusLine": {\n    "type": "command",\n    "command": "bash ~\/.claude\/statusline-wrapper.sh"\n  }\n}/' "$CLAUDE_SETTINGS"
        success "Added status line to Claude settings"
      fi
    else
      # Create new settings file
      cat > "$CLAUDE_SETTINGS" << 'CSEOF'
{
  "statusLine": {
    "type": "command",
    "command": "bash ~/.claude/statusline-wrapper.sh"
  }
}
CSEOF
      success "Created Claude settings with status line"
    fi
  fi
fi
else
  header "Skipping Claude Code status line..."
  info "Status line features are only available with Claude Code"
fi

# ---------- Sound Notification ----------
header "Sound notification..."
echo ""
echo -e "  Claude Code can play a sound when it finishes generating"
echo -e "  and is waiting for your input."
echo ""
read -rn1 -p "$(echo -e "${_BLUE}Enable sound notification? (y/n):${_NC} ")" enable_sound </dev/tty
echo ""

if [[ "$enable_sound" =~ ^[yY]$ ]]; then
  CLAUDE_SETTINGS="$HOME/.claude/settings.json"
  mkdir -p ~/.claude

  # Use Python (ships with macOS) to safely merge hook into settings.json
  if python3 - "$CLAUDE_SETTINGS" << 'PYEOF'
import json, sys, os

settings_path = sys.argv[1]

# Load existing settings or start fresh
if os.path.exists(settings_path):
    try:
        with open(settings_path, "r") as f:
            settings = json.load(f)
    except (json.JSONDecodeError, ValueError):
        settings = {}
else:
    settings = {}

# Build the hook entry we want
new_hook_entry = {
    "matcher": "idle_prompt",
    "hooks": [
        {
            "type": "command",
            "command": "afplay /System/Library/Sounds/Bottle.aiff &"
        }
    ]
}

# Ensure hooks.Notification exists
hooks = settings.setdefault("hooks", {})
notification_list = hooks.setdefault("Notification", [])

# Check if idle_prompt hook already exists
already_exists = any(
    entry.get("matcher") == "idle_prompt"
    for entry in notification_list
)

if not already_exists:
    notification_list.append(new_hook_entry)
    with open(settings_path, "w") as f:
        json.dump(settings, f, indent=2)
        f.write("\n")
    print("added")
else:
    print("exists")
PYEOF
  then
    success "Sound notification configured"
  else
    warn "Failed to configure sound notification"
  fi
else
  info "Skipping sound notification"
fi

# ---------- Tab Title Animation ----------
header "Tab title animation..."
echo ""
echo -e "  Show a spinning animation in the tab title when Claude"
echo -e "  is waiting for your input."
echo ""
read -rn1 -p "$(echo -e "${_BLUE}Enable tab animation? (y/n):${_NC} ")" enable_spinner </dev/tty
echo ""

if [[ "$enable_spinner" =~ ^[yY]$ ]]; then
  mkdir -p ~/.claude

  # Create start script
  cat > ~/.claude/tab-spinner-start.sh << 'SPINSTART'
#!/bin/bash

# Get project name from PWD or tmux session
PROJECT="${PWD##*/}"
if command -v tmux &>/dev/null && tmux list-sessions &>/dev/null; then
  SESSION_NAME=$(tmux display-message -p '#S' 2>/dev/null)
  [ -n "$SESSION_NAME" ] && PROJECT="$SESSION_NAME"
fi

# PID file for this project
PID_FILE="/tmp/ghost-tab-spinner-${PROJECT}.pid"

# Exit if already running
if [ -f "$PID_FILE" ]; then
  OLD_PID=$(cat "$PID_FILE")
  if kill -0 "$OLD_PID" 2>/dev/null; then
    exit 0
  fi
  rm -f "$PID_FILE"
fi

# Spinner frames
FRAMES=(⠋ ⠙ ⠹ ⠸ ⠼ ⠴ ⠦ ⠧ ⠇ ⠏)

# Run animation in background
(
  echo $$ > "$PID_FILE"
  i=0
  while true; do
    printf '\033]0;%s %s\007' "${FRAMES[$i]}" "$PROJECT"
    i=$(( (i + 1) % ${#FRAMES[@]} ))
    sleep 0.1
  done
) &

disown
SPINSTART

  # Create stop script
  cat > ~/.claude/tab-spinner-stop.sh << 'SPINSTOP'
#!/bin/bash

# Get project name from PWD or tmux session
PROJECT="${PWD##*/}"
if command -v tmux &>/dev/null && tmux list-sessions &>/dev/null; then
  SESSION_NAME=$(tmux display-message -p '#S' 2>/dev/null)
  [ -n "$SESSION_NAME" ] && PROJECT="$SESSION_NAME"
fi

# PID file for this project
PID_FILE="/tmp/ghost-tab-spinner-${PROJECT}.pid"

# Kill spinner if running
if [ -f "$PID_FILE" ]; then
  PID=$(cat "$PID_FILE")
  kill "$PID" 2>/dev/null
  rm -f "$PID_FILE"
fi

# Restore normal tab title
printf '\033]0;%s\007' "$PROJECT"
SPINSTOP

  chmod +x ~/.claude/tab-spinner-start.sh
  chmod +x ~/.claude/tab-spinner-stop.sh
  success "Created spinner scripts"

  # Add hooks to settings.json using Python
  CLAUDE_SETTINGS="$HOME/.claude/settings.json"
  if python3 - "$CLAUDE_SETTINGS" << 'PYEOF'
import json, sys, os

settings_path = sys.argv[1]

# Load existing settings or start fresh
if os.path.exists(settings_path):
    try:
        with open(settings_path, "r") as f:
            settings = json.load(f)
    except (json.JSONDecodeError, ValueError):
        settings = {}
else:
    settings = {}

hooks = settings.setdefault("hooks", {})

# Add idle_prompt notification for start script
notification_list = hooks.setdefault("Notification", [])
start_cmd = "bash ~/.claude/tab-spinner-start.sh &"

# Find or create idle_prompt matcher group
idle_group = None
for group in notification_list:
    if group.get("matcher") == "idle_prompt":
        idle_group = group
        break

if idle_group is None:
    idle_group = {"matcher": "idle_prompt", "hooks": []}
    notification_list.append(idle_group)

# Add start command if not already present
if not any(h.get("command") == start_cmd for h in idle_group["hooks"]):
    idle_group["hooks"].append({"type": "command", "command": start_cmd})

# Add UserPromptSubmit hook for stop script
submit_list = hooks.setdefault("UserPromptSubmit", [])
stop_cmd = "bash ~/.claude/tab-spinner-stop.sh"

# UserPromptSubmit doesn't use matchers, just a hooks array
# Find or create the matcher group (use empty string as matcher)
submit_group = None
for group in submit_list:
    if group.get("matcher") == "":
        submit_group = group
        break

if submit_group is None:
    submit_group = {"matcher": "", "hooks": []}
    submit_list.append(submit_group)

if not any(h.get("command") == stop_cmd for h in submit_group["hooks"]):
    submit_group["hooks"].append({"type": "command", "command": stop_cmd})

with open(settings_path, "w") as f:
    json.dump(settings, f, indent=2)
    f.write("\n")
PYEOF
  then
    success "Tab animation hooks configured"
  else
    warn "Failed to configure tab animation hooks"
  fi
else
  info "Skipping tab animation"
fi

# ---------- Summary ----------
header "Setup complete!"
echo ""
success "Wrapper script:  ~/.config/ghostty/claude-wrapper.sh"
success "Ghostty config:  ~/.config/ghostty/config"
_ai_default="$(cat "${XDG_CONFIG_HOME:-$HOME/.config}/ghost-tab/ai-tool" 2>/dev/null)"
success "AI tool:         $(echo "$_ai_default" | sed 's/claude/Claude Code/;s/codex/Codex CLI/;s/copilot/Copilot CLI/;s/opencode/OpenCode/')"
success "Projects file:   $PROJECTS_FILE"
if [ -f ~/.claude/statusline-wrapper.sh ]; then
  success "Status line:     ~/.claude/statusline-wrapper.sh"
fi
if grep -q '"idle_prompt"' ~/.claude/settings.json 2>/dev/null; then
  success "Sound:           Notification on idle"
fi
if [ -f ~/.claude/tab-spinner-start.sh ]; then
  success "Tab animation:   Spinner on idle"
fi
echo ""
info "Open a new Ghostty window to start coding."

} # end main

main "$@"
